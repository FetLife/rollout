= rollout

Feature flippers.

== MAKE SURE TO READ THIS: 2.0 Changes and Migration Path

As of rollout-2.x, only one key is used per feature for performance reasons. The data format is <tt>percentage|user_id,user_id,...|group,_group...</tt>. This has the effect of making concurrent feature modifications unsafe, but in practice, I doubt this will actually be a problem.

This also has the effect of rollout no longer being dependent on redis. Just give it something that responds to <tt>set(key,value)</tt> and <tt>get(key)</tt>.

If you have been using the 1.x format, you can initialize Rollout with <tt>:migrate => true</tt> and it'll do its best to automatically migrate your old features to the new format. There will be some performance impact, but it should be limited and short-lived since each feature only needs to get migrated once.

== Rollout::Legacy

If you'd prefer to continue to use the old layout in redis, <tt>Rollout::Legacy</tt> is a copy and paste of the old code :-).

== Install it

  gem install rollout

== How it works

Initialize a rollout object. I assign it to a global var.

  $redis   = Redis.new
  $rollout = Rollout.new($redis)

Check whether a feature is active for a particular user:
  
  $rollout.active?(:chat, User.first) # => true/false

Check whether a feature is active globally:

  $rollout.active?(:chat)

You can activate features using a number of different mechanisms.

== Groups

Rollout ships with one group by default: "all", which does exactly what it sounds like. 

You can activate the all group for the chat feature like this:

  $rollout.activate_group(:chat, :all)

You might also want to define your own groups. We have one for our caretakers:

  $rollout.define_group(:caretakers) do |user|
    user.caretaker?
  end

You can activate multiple groups per feature.

Deactivate groups like this:

  $rollout.deactivate_group(:chat, :all)

== Specific Users

You might want to let a specific user into a beta test or something. If that user isn't part of an existing group, you can let them in specifically:
  
  $rollout.activate_user(:chat, @user)

Deactivate them like this:

  $rollout.deactivate_user(:chat, @user)

== User Percentages

If you're rolling out a new feature, you might want to test the waters by slowly enabling it for a percentage of your users.

  $rollout.activate_percentage(:chat, 20)

The algorithm for determining which users get let in is this:

  user.id % 10 < percentage / 10

So, for 20%, users 0, 1, 10, 11, 20, 21, etc would be allowed in. Those users would remain in as the percentage increases.

Deactivate all percentages like this:

  $rollout.deactivate_percentage(:chat)

_Note that activating a feature for 100% of users will also make it active "globally". That is when calling Rollout#active? without a user object._

== IP Adresses

As the user and group functions heavily rely on already having a User some might also want to activate specific functions for anonymous visitors or on an IP Address based mechanism. Therefor you can add IP Addresses to the list of activated items for a feature or map visitors IP Addresses against a percentage for a feature.

For example activating the feature "landing_page_new" for a specific IP Address : 


  $rollout.activate_ip(:landing_page_new, "8.8.8.8")


Deactivating the feature "landing_page_new" for a specific IP Address:


  $rollout.activate_ip(:landing_page_new, "8.8.8.8")


In your code you can check if an IP is activated for a feature like this:


  $rollout.active_ip?(:landing_page_new, request.env['REMOTE_ADDR'])


Of course the global deactivating of a feature works for IP Addresses as well.

*Attention*

As the algorithm for percentage converts the IP Address to the int representative and does a modulus 100. 

Practialy it means that not all visitors accessing your webpage have IP Addresses following each other and the optimum percentage will not be achieved. But it's kind of the best effort to come very close to the percentage.

== Feature is broken

Deactivate everybody at once:

  $rollout.deactivate(:chat)

For many of our features, we keep track of error rates using redis, and deactivate them automatically when a threshold is reached to prevent service failures from cascading. See http://github.com/jamesgolick/degrade for the failure detection code.

== Namespacing

Rollout separates its keys from other keys in the data store using the "feature" keyspace.

If you're using redis, you can namespace keys further to support multiple environments by using the http://github.com/defunkt/redis-namespace gem.

  $ns = Redis::Namespace.new(Rails.env, :redis => $redis)
  $rollout = Rollout.new($ns)
  $rollout.activate_group(:chat, :all)
  
This example would use the "development:feature:chat:groups" key.

== misc/check_rollout.rb

In our infrastructure, rollout obviously allows us to progressively enable new features but we also use it to automatically disable features and services that break or fail to prevent them from causing cascading failures and wiping out our entire system.

When a feature reaches "maturity" - in other words, expected to be at 100% rollout all the time - we use check_rollout.rb to setup nagios alerts on the rollouts so that we get paged if one of them gets disabled.


== Implementations in other languages

* Python: http://github.com/asenchi/proclaim

== Copyright

Copyright (c) 2010 James Golick, BitLove, Inc. See LICENSE for details.
